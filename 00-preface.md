# Preface {.unnumbered}

This book started with a casual conversation with Mr. Jim Steddum.
I suggested some analytical topics that I think all Warrant Officers should learn.
He told me that the Army wants to add "data literacy" topics to Warrant Officer
Professional Military Education. I provided an outline with some proposed
topics. That outline then formed the basis for this book.

This book contains a lot of code. The reader is *not* expected to be fluent or even familiar
with *any* of the programming languages used. These programs are provided as an
interactive learning opportunity. Source code in this text is provided along with
links to online "playgrounds" where one can edit and run the code using a web browser.
This gives the reader an opportunity to work directly with the material, testing
ideas and learning new technologies. Another reason for teaching with code is
that mathematical notation often hides complexity that one cannot ignore when
solving practical problems.

This book also contains some math. I mostly avoid calculus, except where it is
necessary to explain the normal distribution (section \ref{sec:normal}) and just
especially fun regarding least squares (section \ref{sec:least-squares-method}).

I present a few original ideas in this book:

 - Models of imperative programming (figure \ref{fig:imperative}), declarative
programming (figure \ref{fig:declarative}), and artificial intelligence (figure
\ref{fig:ai}).
 - An unconventional claim that almost all programs meet some definition for AI
and therefore the term "AI" is ultimately meaningless (section \ref{sec:everything-is-ai}).
 - Monte Carlo solution and algebraic proof for the "milk and coffee" problem (section \ref{sec:milk-and-coffee}).
 - Reduction of the Stable Marriage problem as a (slow) A* solution (section \ref{sec:stable-marriage}).
 - Correlation matrices using Chatterjee correlation instead of Pearson correlation (section todo).

All of the programs in this book are my own except for the Sudoku 

This book also contains some opinions. In general, I favor:

 - Strongly- and statically-typed languages.
 - Databases with static schema.
 - Simple solutions that we can understand, explain, and (sometimes) implement for ourselves.

I do 
